// Code generated by MockGen. DO NOT EDIT.
// Source: find.go
//
// Generated by this command:
//
//	mockgen -destination=mock_test.go -package=app_test -source=find.go
//

// Package app_test is a generated GoMock package.
package app_test

import (
	context "context"
	reflect "reflect"

	domain "github.com/natsoman/youtube-chat-reader/apps/finder/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockTransactor is a mock of Transactor interface.
type MockTransactor struct {
	ctrl     *gomock.Controller
	recorder *MockTransactorMockRecorder
	isgomock struct{}
}

// MockTransactorMockRecorder is the mock recorder for MockTransactor.
type MockTransactorMockRecorder struct {
	mock *MockTransactor
}

// NewMockTransactor creates a new mock instance.
func NewMockTransactor(ctrl *gomock.Controller) *MockTransactor {
	mock := &MockTransactor{ctrl: ctrl}
	mock.recorder = &MockTransactorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactor) EXPECT() *MockTransactorMockRecorder {
	return m.recorder
}

// Atomic mocks base method.
func (m *MockTransactor) Atomic(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Atomic", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Atomic indicates an expected call of Atomic.
func (mr *MockTransactorMockRecorder) Atomic(ctx, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Atomic", reflect.TypeOf((*MockTransactor)(nil).Atomic), ctx, fn)
}

// MockOutbox is a mock of Outbox interface.
type MockOutbox struct {
	ctrl     *gomock.Controller
	recorder *MockOutboxMockRecorder
	isgomock struct{}
}

// MockOutboxMockRecorder is the mock recorder for MockOutbox.
type MockOutboxMockRecorder struct {
	mock *MockOutbox
}

// NewMockOutbox creates a new mock instance.
func NewMockOutbox(ctrl *gomock.Controller) *MockOutbox {
	mock := &MockOutbox{ctrl: ctrl}
	mock.recorder = &MockOutboxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOutbox) EXPECT() *MockOutboxMockRecorder {
	return m.recorder
}

// InsertLiveStreamsFound mocks base method.
func (m *MockOutbox) InsertLiveStreamsFound(ctx context.Context, liveStreams []domain.LiveStream) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertLiveStreamsFound", ctx, liveStreams)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertLiveStreamsFound indicates an expected call of InsertLiveStreamsFound.
func (mr *MockOutboxMockRecorder) InsertLiveStreamsFound(ctx, liveStreams any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertLiveStreamsFound", reflect.TypeOf((*MockOutbox)(nil).InsertLiveStreamsFound), ctx, liveStreams)
}

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// Existing mocks base method.
func (m *MockRepository) Existing(ctx context.Context, liveStreamIDs []string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Existing", ctx, liveStreamIDs)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Existing indicates an expected call of Existing.
func (mr *MockRepositoryMockRecorder) Existing(ctx, liveStreamIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Existing", reflect.TypeOf((*MockRepository)(nil).Existing), ctx, liveStreamIDs)
}

// Insert mocks base method.
func (m *MockRepository) Insert(ctx context.Context, liveStreams []domain.LiveStream) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, liveStreams)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockRepositoryMockRecorder) Insert(ctx, liveStreams any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockRepository)(nil).Insert), ctx, liveStreams)
}

// MockYoutubeClient is a mock of YoutubeClient interface.
type MockYoutubeClient struct {
	ctrl     *gomock.Controller
	recorder *MockYoutubeClientMockRecorder
	isgomock struct{}
}

// MockYoutubeClientMockRecorder is the mock recorder for MockYoutubeClient.
type MockYoutubeClientMockRecorder struct {
	mock *MockYoutubeClient
}

// NewMockYoutubeClient creates a new mock instance.
func NewMockYoutubeClient(ctrl *gomock.Controller) *MockYoutubeClient {
	mock := &MockYoutubeClient{ctrl: ctrl}
	mock.recorder = &MockYoutubeClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockYoutubeClient) EXPECT() *MockYoutubeClientMockRecorder {
	return m.recorder
}

// ListLiveStreams mocks base method.
func (m *MockYoutubeClient) ListLiveStreams(ctx context.Context, videoIDs []string) ([]domain.LiveStream, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListLiveStreams", ctx, videoIDs)
	ret0, _ := ret[0].([]domain.LiveStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListLiveStreams indicates an expected call of ListLiveStreams.
func (mr *MockYoutubeClientMockRecorder) ListLiveStreams(ctx, videoIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLiveStreams", reflect.TypeOf((*MockYoutubeClient)(nil).ListLiveStreams), ctx, videoIDs)
}

// SearchUpcomingLiveStream mocks base method.
func (m *MockYoutubeClient) SearchUpcomingLiveStream(ctx context.Context, channelID string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchUpcomingLiveStream", ctx, channelID)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchUpcomingLiveStream indicates an expected call of SearchUpcomingLiveStream.
func (mr *MockYoutubeClientMockRecorder) SearchUpcomingLiveStream(ctx, channelID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchUpcomingLiveStream", reflect.TypeOf((*MockYoutubeClient)(nil).SearchUpcomingLiveStream), ctx, channelID)
}
