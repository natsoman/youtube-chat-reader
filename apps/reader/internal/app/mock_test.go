// Code generated by MockGen. DO NOT EDIT.
// Source: read.go
//
// Generated by this command:
//
//	mockgen -destination=mock_test.go -package=app_test -source=read.go
//

// Package app_test is a generated GoMock package.
package app_test

import (
	context "context"
	reflect "reflect"
	time "time"

	domain "github.com/natsoman/youtube-chat-reader/apps/reader/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockClock is a mock of Clock interface.
type MockClock struct {
	ctrl     *gomock.Controller
	recorder *MockClockMockRecorder
	isgomock struct{}
}

// MockClockMockRecorder is the mock recorder for MockClock.
type MockClockMockRecorder struct {
	mock *MockClock
}

// NewMockClock creates a new mock instance.
func NewMockClock(ctrl *gomock.Controller) *MockClock {
	mock := &MockClock{ctrl: ctrl}
	mock.recorder = &MockClockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClock) EXPECT() *MockClockMockRecorder {
	return m.recorder
}

// Now mocks base method.
func (m *MockClock) Now() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Now")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// Now indicates an expected call of Now.
func (mr *MockClockMockRecorder) Now() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Now", reflect.TypeOf((*MockClock)(nil).Now))
}

// MockTicker is a mock of Ticker interface.
type MockTicker struct {
	ctrl     *gomock.Controller
	recorder *MockTickerMockRecorder
	isgomock struct{}
}

// MockTickerMockRecorder is the mock recorder for MockTicker.
type MockTickerMockRecorder struct {
	mock *MockTicker
}

// NewMockTicker creates a new mock instance.
func NewMockTicker(ctrl *gomock.Controller) *MockTicker {
	mock := &MockTicker{ctrl: ctrl}
	mock.recorder = &MockTickerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTicker) EXPECT() *MockTickerMockRecorder {
	return m.recorder
}

// Start mocks base method.
func (m *MockTicker) Start(d time.Duration) (<-chan time.Time, func()) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", d)
	ret0, _ := ret[0].(<-chan time.Time)
	ret1, _ := ret[1].(func())
	return ret0, ret1
}

// Start indicates an expected call of Start.
func (mr *MockTickerMockRecorder) Start(d any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockTicker)(nil).Start), d)
}

// MockLiveStreamProgressRepository is a mock of LiveStreamProgressRepository interface.
type MockLiveStreamProgressRepository struct {
	ctrl     *gomock.Controller
	recorder *MockLiveStreamProgressRepositoryMockRecorder
	isgomock struct{}
}

// MockLiveStreamProgressRepositoryMockRecorder is the mock recorder for MockLiveStreamProgressRepository.
type MockLiveStreamProgressRepositoryMockRecorder struct {
	mock *MockLiveStreamProgressRepository
}

// NewMockLiveStreamProgressRepository creates a new mock instance.
func NewMockLiveStreamProgressRepository(ctrl *gomock.Controller) *MockLiveStreamProgressRepository {
	mock := &MockLiveStreamProgressRepository{ctrl: ctrl}
	mock.recorder = &MockLiveStreamProgressRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLiveStreamProgressRepository) EXPECT() *MockLiveStreamProgressRepositoryMockRecorder {
	return m.recorder
}

// Started mocks base method.
func (m *MockLiveStreamProgressRepository) Started(ctx context.Context, startsWithin time.Duration) ([]domain.LiveStreamProgress, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Started", ctx, startsWithin)
	ret0, _ := ret[0].([]domain.LiveStreamProgress)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Started indicates an expected call of Started.
func (mr *MockLiveStreamProgressRepositoryMockRecorder) Started(ctx, startsWithin any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Started", reflect.TypeOf((*MockLiveStreamProgressRepository)(nil).Started), ctx, startsWithin)
}

// Upsert mocks base method.
func (m *MockLiveStreamProgressRepository) Upsert(ctx context.Context, lsp *domain.LiveStreamProgress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, lsp)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockLiveStreamProgressRepositoryMockRecorder) Upsert(ctx, lsp any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockLiveStreamProgressRepository)(nil).Upsert), ctx, lsp)
}

// MockChatMessageStreamer is a mock of ChatMessageStreamer interface.
type MockChatMessageStreamer struct {
	ctrl     *gomock.Controller
	recorder *MockChatMessageStreamerMockRecorder
	isgomock struct{}
}

// MockChatMessageStreamerMockRecorder is the mock recorder for MockChatMessageStreamer.
type MockChatMessageStreamerMockRecorder struct {
	mock *MockChatMessageStreamer
}

// NewMockChatMessageStreamer creates a new mock instance.
func NewMockChatMessageStreamer(ctrl *gomock.Controller) *MockChatMessageStreamer {
	mock := &MockChatMessageStreamer{ctrl: ctrl}
	mock.recorder = &MockChatMessageStreamerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatMessageStreamer) EXPECT() *MockChatMessageStreamerMockRecorder {
	return m.recorder
}

// StreamChatMessages mocks base method.
func (m *MockChatMessageStreamer) StreamChatMessages(ctx context.Context, lsp *domain.LiveStreamProgress) (<-chan domain.ChatMessages, <-chan error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StreamChatMessages", ctx, lsp)
	ret0, _ := ret[0].(<-chan domain.ChatMessages)
	ret1, _ := ret[1].(<-chan error)
	return ret0, ret1
}

// StreamChatMessages indicates an expected call of StreamChatMessages.
func (mr *MockChatMessageStreamerMockRecorder) StreamChatMessages(ctx, lsp any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StreamChatMessages", reflect.TypeOf((*MockChatMessageStreamer)(nil).StreamChatMessages), ctx, lsp)
}

// MockLocker is a mock of Locker interface.
type MockLocker struct {
	ctrl     *gomock.Controller
	recorder *MockLockerMockRecorder
	isgomock struct{}
}

// MockLockerMockRecorder is the mock recorder for MockLocker.
type MockLockerMockRecorder struct {
	mock *MockLocker
}

// NewMockLocker creates a new mock instance.
func NewMockLocker(ctrl *gomock.Controller) *MockLocker {
	mock := &MockLocker{ctrl: ctrl}
	mock.recorder = &MockLockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLocker) EXPECT() *MockLockerMockRecorder {
	return m.recorder
}

// Lock mocks base method.
func (m *MockLocker) Lock(ctx context.Context, key string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", ctx, key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lock indicates an expected call of Lock.
func (mr *MockLockerMockRecorder) Lock(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockLocker)(nil).Lock), ctx, key)
}

// Release mocks base method.
func (m *MockLocker) Release(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockLockerMockRecorder) Release(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockLocker)(nil).Release), ctx, key)
}

// MockBanRepository is a mock of BanRepository interface.
type MockBanRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBanRepositoryMockRecorder
	isgomock struct{}
}

// MockBanRepositoryMockRecorder is the mock recorder for MockBanRepository.
type MockBanRepositoryMockRecorder struct {
	mock *MockBanRepository
}

// NewMockBanRepository creates a new mock instance.
func NewMockBanRepository(ctrl *gomock.Controller) *MockBanRepository {
	mock := &MockBanRepository{ctrl: ctrl}
	mock.recorder = &MockBanRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBanRepository) EXPECT() *MockBanRepositoryMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockBanRepository) Insert(ctx context.Context, bb []domain.Ban) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, bb)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockBanRepositoryMockRecorder) Insert(ctx, bb any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockBanRepository)(nil).Insert), ctx, bb)
}

// MockTextMessageRepository is a mock of TextMessageRepository interface.
type MockTextMessageRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTextMessageRepositoryMockRecorder
	isgomock struct{}
}

// MockTextMessageRepositoryMockRecorder is the mock recorder for MockTextMessageRepository.
type MockTextMessageRepositoryMockRecorder struct {
	mock *MockTextMessageRepository
}

// NewMockTextMessageRepository creates a new mock instance.
func NewMockTextMessageRepository(ctrl *gomock.Controller) *MockTextMessageRepository {
	mock := &MockTextMessageRepository{ctrl: ctrl}
	mock.recorder = &MockTextMessageRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTextMessageRepository) EXPECT() *MockTextMessageRepositoryMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockTextMessageRepository) Insert(ctx context.Context, tms []domain.TextMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, tms)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockTextMessageRepositoryMockRecorder) Insert(ctx, tms any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockTextMessageRepository)(nil).Insert), ctx, tms)
}

// MockDonateRepository is a mock of DonateRepository interface.
type MockDonateRepository struct {
	ctrl     *gomock.Controller
	recorder *MockDonateRepositoryMockRecorder
	isgomock struct{}
}

// MockDonateRepositoryMockRecorder is the mock recorder for MockDonateRepository.
type MockDonateRepositoryMockRecorder struct {
	mock *MockDonateRepository
}

// NewMockDonateRepository creates a new mock instance.
func NewMockDonateRepository(ctrl *gomock.Controller) *MockDonateRepository {
	mock := &MockDonateRepository{ctrl: ctrl}
	mock.recorder = &MockDonateRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDonateRepository) EXPECT() *MockDonateRepositoryMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockDonateRepository) Insert(ctx context.Context, dd []domain.Donate) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, dd)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockDonateRepositoryMockRecorder) Insert(ctx, dd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockDonateRepository)(nil).Insert), ctx, dd)
}

// MockAuthorRepository is a mock of AuthorRepository interface.
type MockAuthorRepository struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorRepositoryMockRecorder
	isgomock struct{}
}

// MockAuthorRepositoryMockRecorder is the mock recorder for MockAuthorRepository.
type MockAuthorRepositoryMockRecorder struct {
	mock *MockAuthorRepository
}

// NewMockAuthorRepository creates a new mock instance.
func NewMockAuthorRepository(ctrl *gomock.Controller) *MockAuthorRepository {
	mock := &MockAuthorRepository{ctrl: ctrl}
	mock.recorder = &MockAuthorRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorRepository) EXPECT() *MockAuthorRepositoryMockRecorder {
	return m.recorder
}

// Upsert mocks base method.
func (m *MockAuthorRepository) Upsert(ctx context.Context, aa []domain.Author) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, aa)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockAuthorRepositoryMockRecorder) Upsert(ctx, aa any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockAuthorRepository)(nil).Upsert), ctx, aa)
}
